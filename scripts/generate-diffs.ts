import YAML from 'yaml';
import fs, { writeFile } from 'node:fs/promises';
import path from 'node:path';
import { execa, execaCommand } from 'execa';
import { parseGitDiff } from './parse-git-diff';
import { serializeDiff } from './serialize-diff';

const skipPullTemplates = process.env.SKIP_PULL_TEMPLATES === 'true';
const cwd = process.cwd();

const { stdout: modifiedFiles } = await execa('git', [
  'ls-files',
  '--modified',
]);
const { stdout: stagedFiles } = await execa('git', [
  'diff',
  '--name-only',
  '--cached',
]);
const { stdout: untrackedFiles } = await execa('git', [
  'ls-files',
  '--others',
  '--exclude-standard',
]);
const changedExampleSourceCode = [
  ...modifiedFiles.split('\n'),
  ...stagedFiles.split('\n'),
  ...untrackedFiles.split('\n'),
].filter(
  (file) => file.startsWith('examples' + path.sep) && !file.includes('README'),
);

console.log();
console.log('Generate Template Diffs');
console.log();

interface Config {
  examplesDir: string;
  template: {
    names: string[];
    generate: string;
  };
}
const config: Config = YAML.parse(
  await fs.readFile('diff.config.yml', 'utf-8'),
);
const getExamplePath = (name: string) => path.resolve(config.examplesDir, name);

// Create template directories

const templates = config.template.names.map((name) => ({
  name,
  path: getExamplePath(name),
}));

// Find examples

console.log('Finding examples...');
await fs.mkdir(config.examplesDir, { recursive: true });
const examples = (await fs.readdir(config.examplesDir))
  .map((name) => ({
    name,
    path: getExamplePath(name),
    base: name.split('-', 2)[0],
  }))
  .filter(
    (example) => !templates.find((template) => template.path === example.path),
  );
examples.forEach((example) => {
  console.log(`  - ${example.name}`);
});
console.log(`${examples.length} examples`);

if (!skipPullTemplates) {
  console.log();
  console.log('Deleting old templates...');
  await Promise.allSettled(
    templates.map(async (template) => {
      await fs.rm(template.path, { force: true });
    }),
  );

  console.log();
  console.log('Recreating templates...');
  await Promise.all(
    templates.map(async (template) => {
      const command = config.template.generate.replaceAll(
        '{{name}}',
        template.name,
      );
      await execaCommand(command, { cwd: config.examplesDir });
      console.log(`  - ${command}`);
    }),
  );
}

// Update branches

console.log();
console.log(`Generating branches...`);

for (const item of [...templates, ...examples]) {
  console.log(`  - ${item.name}`);
  if (item.name === 'main') process.exit(1);
  await execa('git', ['branch', '-D', item.name]).catch(() => {});
  await execa('git', [
    'subtree',
    'split',
    '--branch',
    item.name,
    '--prefix',
    path.relative(cwd, item.path),
  ]).catch(() => {});
}

console.log();
console.log('Generating diffs');
const ignoredFiles = new Set(['README.md', 'README.template.md', '.gitignore']);
const diffs = await Promise.all(
  examples.map(async (example) => {
    console.log(`  - ${example.base}..${example.name}`);
    const { stdout: diff } = await execa('git', [
      'diff',
      '-U6',
      example.base,
      example.name,
    ]).catch(() => ({ stdout: '' }));
    const changes = parseGitDiff(
      diff.replaceAll('_gitignore', '.gitignore'),
    ).filter((change) => !ignoredFiles.has(change.newPath));
    return {
      ...example,
      diff: changes,
    };
  }),
);

console.log();
console.log('Generating READMEs...');
const titles: Record<string, string> = {};
for (const example of diffs) {
  const templatePath = path.resolve(example.path, 'README.template.md');
  const readmePath = path.resolve(example.path, 'README.md');
  console.log(`  - ${path.relative(cwd, readmePath)}`);
  const template = await fs.readFile(
    path.resolve(example.path, templatePath),
    'utf-8',
  );
  titles[example.name] = template
    .match(/^\#\s+(.*)$/gm)?.[0]
    ?.replace('# ', '');
  const unusedFiles = new Set(example.diff.map((diff) => diff.newPath));
  let readme = `<!-- Generated by scripts/generate-diffs.ts -->\n\n${template}\n`;

  const infoReplacements = [
    {
      find: '{{base}}',
      replace: `> Based off the [\`${example.base}\`](https://github.com/wxt-dev/wxt/tree/main/templates/${example.base}) template.
>
> \`\`\`sh
> npx wxt@latest init --template ${example.base}
> \`\`\``,
    },
  ];
  const fileReplacements = example.diff.map((file) => ({
    path: file.newPath,
    find: `{{${file.newPath}}}`,
    replace: serializeDiff(file),
  }));
  ``;
  infoReplacements.forEach(({ find, replace }) => {
    readme = readme.replaceAll(find, replace);
  });
  fileReplacements.forEach(({ find, replace, path }) => {
    if (readme.includes(path)) unusedFiles.delete(path);
    readme = readme.replaceAll(find, replace);
  });

  if (unusedFiles.size > 0) {
    readme += [
      '---',
      '### Other File Changes',
      ...Array.from(unusedFiles).map((file) => {
        const diff = example.diff.find((item) => item.newPath === file);
        return serializeDiff(diff);
      }),
    ].join('\n\n');
  }

  await fs.writeFile(readmePath, readme, 'utf-8');
  await execa('prettier', ['--write', readmePath]);
}

console.log();
console.log('Updating examples.json...');
const json = examples.map((template) => ({
  name: titles[template.name] ?? template.name,
  url: `https://github.com/wxt-dev/wxt-examples/tree/main/examples/${template.name}/README.md`,
}));
await writeFile('examples.json', JSON.stringify(json, null, 2) + '\n', 'utf-8');

if (changedExampleSourceCode.length > 0) {
  console.log();
  console.warn(
    '\x1b[33m\x1b[1mUncommitted files in the example directory are ignored while generating diffs. Commit the changes to effect README.md generation.',
  );
  changedExampleSourceCode.forEach((file) => {
    console.log(`  - ${file}`);
  });
  console.log('\x1b[0m');
}
