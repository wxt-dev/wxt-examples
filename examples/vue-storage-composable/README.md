<!-- Generated by scripts/generate-diffs.ts -->

# Vue Storage Composable

> Based off the [`vue`](https://github.com/wxt-dev/wxt/tree/main/templates/vue) template.
>
> ```sh
> npx wxt@latest init --template vue
> ```

WXT's storage API is based on [`unstorage`](https://unstorage.unjs.io/). While [`@vueuse/core`'s `useStorageAsync`](https://vueuse.org/core/useStorageAsync/#usestorageasync) composable accepts a storage object from `unstorage`, it does not watch for changes. So if you want a truly reactive composable, we need to write it ourselves.

The composable will use [`@vueuse/core`'s `useAsyncState`](https://vueuse.org/core/useAsyncState/#useasyncstate), so let's install it:

###### package.json

```diff
@@ -12,15 +12,16 @@
     "zip": "wxt zip",
     "zip:firefox": "wxt zip -b firefox",
     "compile": "vue-tsc --noEmit",
     "postinstall": "wxt prepare"
   },
   "dependencies": {
+    "@vueuse/core": "^10.6.1",
     "vue": "^3.3.4"
   },
   "devDependencies": {
-    "@vitejs/plugin-vue": "^4.5.1",
-    "typescript": "^5.3.2",
-    "vue-tsc": "^1.8.25",
-    "wxt": "^0.11.0"
+    "@vitejs/plugin-vue": "^4.2.3",
+    "typescript": "^5.1.6",
+    "vue-tsc": "^1.8.4",
+    "wxt": "^0.10.0"
   }
 }
```

Let's write the composable:

1. Call `useAsyncState` to initialize the state
2. When the component is mounted, add a listener that watches for storage changes
3. When the component is unmounted, remove the listener
4. Instead of returning the state directly, return a "writable computed ref" that updates the value in storage when a new value is set

###### composables/useStoredValue.ts

```ts
import { UseAsyncStateOptions, useAsyncState } from '@vueuse/core';
import useStorage from './useStorage';
import { computed, onMounted, onUnmounted } from 'vue';

export default function <
  T extends StorageValue,
  Shallow extends boolean = true,
>(
  key: string,
  initialValue?: T,
  opts?: UseAsyncStateOptions<Shallow, T | null>,
) {
  const { state, ...asyncState } = useAsyncState<T | null, [], Shallow>(
    () => storage.getItem(key),
    initialValue ?? null,
    opts,
  );

  // Listen for changes
  let unwatch: Promise<() => void> | undefined;
  onMounted(() => {
    unwatch = storage.watch(async (event, changedKey) => {
      if (key !== changedKey) return;
      if (event === 'remove') state.value = null;
      else asyncState.execute();
    });
  });
  onUnmounted(() => {
    unwatch?.then((fn) => fn());
  });

  return {
    // Use a writable computed ref to write updates to storage
    state: computed({
      get() {
        return state.value;
      },
      set(newValue) {
        void storage.setItem(key, newValue);
        state.value = newValue;
      },
    }),
    ...asyncState,
  };
}

type StorageValue = null | string | number | boolean | object;
```

Lets setup a interval in our background that increments a counter in `browser.storage.session` storage:

###### entrypoints/background.ts

```diff
@@ -1,3 +1,9 @@
 export default defineBackground(() => {
   console.log('Hello background!', { id: browser.runtime.id });
+
+  setInterval(async () => {
+    const oldValue = await storage.getItem<number>('session:count');
+    const newValue = (oldValue ?? 0) + 1;
+    await storage.setItem('session:count', newValue);
+  }, 1000);
 });
```

And we can read and update the value like so from the UI:

###### components/HelloWorld.vue

```diff
@@ -2,20 +2,24 @@
 import { ref } from 'vue';

 defineProps({
   msg: String,
 });

-const count = ref(0);
+const { state: count } = useStoredValue<number>('session:count', 0);
+
+function increment() {
+  count.value = (count.value ?? 0) + 1;
+}
 </script>

 <template>
   <h1>{{ msg }}</h1>

   <div class="card">
-    <button type="button" @click="count++">count is {{ count }}</button>
+    <button type="button" @click="increment">count is {{ count }}</button>
     <p>
       Edit
       <code>components/HelloWorld.vue</code> to test HMR
     </p>
   </div>

```

---

### Other File Changes

###### wxt.config.ts

```diff
@@ -8,7 +8,10 @@ export default defineConfig({
       vueTemplate: true,
     },
   },
   vite: () => ({
     plugins: [vue()],
   }),
+  manifest: {
+    permissions: ['storage'],
+  },
 });
```
