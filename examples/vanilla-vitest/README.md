<!-- Generated by scripts/generate-diffs.ts -->

# Vitest

WXT has first class support for running unit tests with [Vitest](https://vitest.dev/).

First, start by installing Vitest:

###### package.json

```diff
@@ -9,13 +9,15 @@
     "dev:firefox": "wxt -b firefox",
     "build": "wxt build",
     "build:firefox": "wxt build -b firefox",
     "zip": "wxt zip",
     "zip:firefox": "wxt zip -b firefox",
     "compile": "tsc --noEmit",
-    "postinstall": "wxt prepare"
+    "postinstall": "wxt prepare",
+    "test": "vitest"
   },
   "devDependencies": {
     "typescript": "^5.3.2",
+    "vitest": "^1.1.0",
     "wxt": "^0.12.0"
   }
 }
```

Then, create a Vitest config file, importing WXT and adding the plugin to automatically configure Vitest for WXT:

- Configure auto-imports
- Mock `browser` API
- Setup TSConfig paths
- Resolve remote URLs
- Define global variables

###### vitest.config.ts

```ts
console.log('vitest.config.ts');
import { defineConfig } from 'vitest/config';
import { WxtVitest } from 'wxt/testing';

export default defineConfig({
  // Configure test behavior however you like
  test: {
    mockReset: true,
    restoreMocks: true,
  },
  ssr: {
    noExternal: ['wxt'],
  },
  // This is the line that matters!
  plugins: [WxtVitest()],
});
```

And that's it, you're all setup!

For an example test, lets you want to save the date your extension was installed to storage:

###### entrypoints/background.ts

```diff
@@ -1,3 +1,7 @@
 export default defineBackground(() => {
-  console.log('Hello background!', { id: browser.runtime.id });
+  browser.runtime.onInstalled.addListener(({ reason }) => {
+    if (reason === 'install') {
+      storage.setItem('local:installDate', new Date().toISOString());
+    }
+  });
 });
```

It's very simple to write some unit tests to cover this:

###### entrypoints/**tests**/background.test.ts

```ts
console.log('background.test.ts');
import { describe, it, expect, vi, beforeEach } from 'vitest';
import background from '../background';
import { fakeBrowser } from 'wxt/testing';
import { Runtime } from 'wxt/browser';

describe('Background Entrypoint', () => {
  beforeEach(() => {
    // Reset the in-memory state, including storage
    fakeBrowser.reset();
  });

  it('should store the current date on install', async () => {
    const expected = '2023-12-22T15:27:25.950Z';
    vi.setSystemTime(expected);

    background.main();
    await fakeBrowser.runtime.onInstalled.trigger({
      reason: 'install',
      temporary: false,
    });
    const actual = await storage.getItem('local:installDate');

    expect(actual).toBe(expected);
  });

  it.each<Runtime.OnInstalledReason>(['update', 'browser_update'])(
    'should not store the current date on %s',
    async (reason) => {
      const previous = '2023-12-22T15:27:25.950Z';
      await storage.setItem('local:installDate', previous);

      background.main();
      await fakeBrowser.runtime.onInstalled.trigger({
        reason,
        temporary: false,
      });
      const actual = await storage.getItem('local:installDate');

      expect(actual).toBe(previous);
    },
  );
});
```

As you can see, we're can use the `browser` global like we would in a real extension. The `browser` is mocked with an in-memory implementation via [`@webext-core/fake-browser`](https://webext-core.aklinker1.io/guide/fake-browser/). See their docs for more examples and details about which APIs are implemented.

---

### Other File Changes

###### wxt.config.ts

```diff
@@ -1,4 +1,8 @@
 import { defineConfig } from 'wxt';

 // See https://wxt.dev/api/config.html
-export default defineConfig({});
+export default defineConfig({
+  manifest: {
+    permissions: ['storage'],
+  },
+});
```
